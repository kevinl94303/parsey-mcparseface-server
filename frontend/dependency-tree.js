// Generated by CoffeeScript 2.3.2
(function() {
  var getDependencyParse, levelHeight, maximum, parseConll, under, wordHeight, wordWidth;

  wordWidth = 100;

  wordHeight = 20;

  levelHeight = function(level) {
    return 2 + Math.pow(level, 1.8) * 10;
  };

  window.drawTree = async function(svgElement, doc) {
    var arrows, conllData, data, dependencies, e, edge, edges, i, item, j, k, len, len1, len2, svg, tags, treeHeight, treeWidth, triangle, words;
    svg = d3.select(svgElement);
    svg.attr('width', function() {
      return wordWidth;
    }).attr('height', function() {
      return wordHeight * 2;
    }).append('text').text(function() {
      return "Loading...";
    }).attr('class', function() {
      return "tag";
    }).attr('x', function() {
      return wordWidth / 2;
    }).attr('y', function() {
      return wordHeight * 3 / 2;
    }).attr('text-anchor', 'middle');
    conllData = (await getDependencyParse(doc));
    data = parseConll(conllData);
    // compute edge levels
    edges = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = data.length; i < len; i++) {
        item = data[i];
        if (item.id) {
          results.push(item);
        }
      }
      return results;
    })();
    for (i = 0, len = edges.length; i < len; i++) {
      edge = edges[i];
      for (j = 0, len1 = edges.length; j < len1; j++) {
        edge = edges[j];
        edge.level = 1 + maximum((function() {
          var k, len2, results;
          results = [];
          for (k = 0, len2 = edges.length; k < len2; k++) {
            e = edges[k];
            if (under(edge, e)) {
              results.push(e.level);
            }
          }
          return results;
        })());
      }
    }
    // compute height
    treeWidth = wordWidth * data.length;
    treeHeight = levelHeight(maximum((function() {
      var k, len2, results;
      results = [];
      for (k = 0, len2 = data.length; k < len2; k++) {
        edge = data[k];
        results.push(edge.level);
      }
      return results;
    })())) + 2 * wordHeight;
    for (k = 0, len2 = data.length; k < len2; k++) {
      item = data[k];
      item.bottom = treeHeight - 1.8 * wordHeight;
      item.top = item.bottom - levelHeight(item.level);
      item.left = item.id * wordWidth + (wordWidth / 2);
      item.right = item.parent * wordWidth + (wordWidth / 2);
      item.mid = (item.right + item.left) / 2;
      item.diff = (item.right - item.left) / 4;
      item.arrow = item.top + (item.bottom - item.top) * .25;
    }
    // draw svg
    svg.selectAll('text, path').remove();
    svg.attr('xmlns', 'http://www.w3.org/2000/svg');
    svg.attr('width', treeWidth).attr('height', treeHeight + wordHeight / 2);
    words = svg.selectAll('.word').data(data).enter().append('text').text(function(d) {
      return d.word;
    }).attr('class', function(d) {
      return `word w${d.id}`;
    }).attr('x', function(d) {
      return wordWidth * d.id + (wordWidth / 2);
    }).attr('y', treeHeight - wordHeight).on('mouseover', function(d) {
      svg.selectAll('.word, .dependency, .edge, .arrow').classed('active', false);
      svg.selectAll('.tag').attr('opacity', 0);
      svg.selectAll(`.w${d.id}`).classed('active', true);
      return svg.select(`.tag.w${d.id}`).attr('opacity', 1);
    }).on('mouseout', function(d) {
      svg.selectAll('.word, .dependency, .edge, .arrow').classed('active', false);
      return svg.selectAll('.tag').attr('opacity', 0);
    }).attr('text-anchor', 'middle');
    tags = svg.selectAll('.tag').data(data).enter().append('text').text(function(d) {
      return d.tag;
    }).attr('class', function(d) {
      return `tag w${d.id}`;
    }).attr('x', function(d) {
      return wordWidth * d.id + (wordWidth / 2);
    }).attr('y', treeHeight).attr('opacity', 0).attr('text-anchor', 'middle').attr('font-size', '90%');
    edges = svg.selectAll('.edge').data(data).enter().append('path').filter(function(d) {
      return d.id;
    }).attr('class', function(d) {
      return `edge w${d.id} w${d.parent}`;
    }).attr('d', function(d) {
      return `M${d.left},${d.bottom} C${d.mid - d.diff},${d.top} ${d.mid + d.diff},${d.top} ${d.right},${d.bottom}`;
    }).attr('fill', 'none').attr('stroke', 'black').attr('stroke-width', '1.5');
    dependencies = svg.selectAll('.dependency').data(data).enter().append('text').filter(function(d) {
      return d.id;
    }).text(function(d) {
      return d.dependency;
    }).attr('class', function(d) {
      return `dependency w${d.id} w${d.parent}`;
    }).attr('x', function(d) {
      return d.mid;
    }).attr('y', function(d) {
      return d.arrow - 7;
    }).attr('text-anchor', 'middle').attr('font-size', '90%');
    triangle = d3.svg.symbol().type('triangle-up').size(5);
    return arrows = svg.selectAll('.arrow').data(data).enter().append('path').filter(function(d) {
      return d.id;
    }).attr('class', function(d) {
      return `arrow w${d.id} w${d.parent}`;
    }).attr('d', triangle).attr('transform', function(d) {
      return `translate(${d.mid}, ${d.arrow}) rotate(${(d.id < d.parent ? '' : '-')}90)`;
    }).attr('fill', 'none').attr('stroke', 'black').attr('stroke-width', '1.5');
  };

  // functions
  maximum = function(array) {
    return Math.max(0, Math.max.apply(null, array));
  };

  under = function(edge1, edge2) {
    var ma, mi;
    [mi, ma] = edge1.id < edge1.parent ? [edge1.id, edge1.parent] : [edge1.parent, edge1.id];
    return edge1.id !== edge2.id && edge2.id >= mi && edge2.parent >= mi && edge2.id <= ma && edge2.parent <= ma;
  };

  parseConll = function(conllData) {
    var _, cpos, data, dependency, fpos, i, id, len, line, parent, ref, tag, word;
    data = [];
    data.push({
      id: 0,
      word: 'ROOT',
      tag: 'ROOT',
      level: 0
    });
    ref = conllData.split('\n');
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      if (!(line)) {
        continue;
      }
      [id, word, _, cpos, fpos, _, parent, dependency] = line.split('\t');
      tag = cpos !== fpos ? cpos + ' ' + fpos : cpos;
      data.push({
        id: Number(id),
        word: word,
        tag: tag,
        parent: Number(parent),
        dependency: dependency,
        level: 1
      });
    }
    return data;
  };

  getDependencyParse = function(doc) {
    return fetch('/', {
      method: "POST",
      body: JSON.stringify({
        doc: doc
      }),
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    }).then(function(res) {
      return res.json();
    }).then(function(body) {
      return body['body'];
    });
  };

}).call(this);
